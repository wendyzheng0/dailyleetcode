from typing import List


###
# 给你一个下标从 1 开始的二进制矩阵，其中 0 表示陆地，1 表示水域。同时给你 row 和 col 分别表示矩阵中行和列的数目。
# 一开始在第 0 天，整个 矩阵都是 陆地 。但每一天都会有一块新陆地被 水 淹没变成水域。给你一个下标从 1 开始的二维数组 cells ，其中 cells[i] = [ri, ci] 表示在第 i 天，第 ri 行 ci 列（下标都是从 1 开始）的陆地会变成 水域 （也就是 0 变成 1 ）。
# 你想知道从矩阵最 上面 一行走到最 下面 一行，且只经过陆地格子的 最后一天 是哪一天。你可以从最上面一行的 任意 格子出发，到达最下面一行的 任意 格子。你只能沿着 四个 基本方向移动（也就是上下左右）。
# 请返回只经过陆地格子能从最 上面 一行走到最 下面 一行的 最后一天 。
#
# 由于cells里面所有格子唯一，而且cells.length == row * col, 所以最终所有陆地都会变成水。于是可以倒着想从水变成陆地的过程，直到有一条路可以从第一行到最后一行就可以停止了。
# 当第idx天个字rowi,coli从水变成陆地之后，检查它是否可以走到第一行。如果可以，把它连同的陆地都标记为2，表示已经可以走到第一行。同时检查这些联通的陆地里面有没有在最后一行的，如果有就找到最早的一天了。
# 方法二，上面的方法只适用于最后陆地全部变成水的情况。如果陆地没有全变成水，我们需要换个思路。可以想象当第一行无法到达最后一行的时候，就是有一条水路可以从第一列到达最后一列的时候。
# 由于对角两个水格子可以把陆地分开，所以对于水来说可以向8个方向扩撒。然后用类似方法，正序遍历cells。把可以到达第一列的水格子标记为2，否则为1.当新格子可以到达第一列时，需要把它所联通
# 的其他值为1的水格子也设成2，直到有一个水格子可以到达最后一列，那么这一天就是答案。
# 考虑到联通性，这题也可以用并查集来做。也需要倒过来从水到陆地的过程，增加两个点表示第一行和最后一行。每次把新陆地和它四个方向的陆地联通，直到第一行和最后一行联通。
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        land = [[1] * col for _ in range(row)]
        dirs = [(-1, 0), (0, -1), (0, 1), (1, 0)]

        def can_reach_top(r, c):
            if r == 0:
                return True
            for dr, dc in dirs:
                rr, cc = r + dr, c + dc
                if 0 <= rr < row and 0 <= cc < col and land[rr][cc] == 2:
                    return True
            return False

        def expand_to_bottom(r, c):
            if r == row - 1:
                return True
            land[r][c] = 2
            for dr, dc in dirs:
                rr, cc = r + dr, c + dc
                if 0 <= rr < row and 0 <= cc < col and land[rr][cc] == 0 and expand_to_bottom(rr, cc):
                    return True
            return False

        for idx in range(len(cells) - 1, -1, -1):
            r, c = cells[idx]
            r -= 1
            c -= 1
            land[r][c] = 0
            if can_reach_top(r, c) and expand_to_bottom(r, c):
                return idx
        return 0


if __name__ == "__main__":
    solution = Solution()
    print(solution.latestDayToCross(2, 2, [[1,1],[2,1],[1,2],[2,2]])) # 2
    print(solution.latestDayToCross(2, 2, [[1,1],[1,2],[2,1],[2,2]])) # 1
    print(solution.latestDayToCross(3, 3, [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]])) # 3
    print(solution.latestDayToCross(2, 6, [[1,4],[1,3],[2,1],[2,5],[2,2],[1,5],[2,4],[1,2],[1,6],[2,3],[2,6],[1,1]])) # 8
    print(solution.latestDayToCross(13, 9, [[12,6],[3,4],[2,9],[9,4],[9,2],[6,4],[4,4],[8,6],[4,9],[5,6],[7,5],[12,4],[11,8],[3,7],[2,6],[9,8],[3,5],[13,4],[1,3],[10,2],[8,9],[6,6],[11,7],[11,1],[13,9],[12,7],[10,7],[8,2],[1,8],[7,3],[6,5],[2,1],[10,6],[4,8],[4,2],[9,7],[6,2],[3,6],[12,2],[10,3],[10,5],[9,5],[8,8],[8,7],[3,2],[13,6],[3,1],[5,1],[2,7],[8,3],[12,5],[11,2],[6,3],[1,4],[13,3],[4,1],[9,9],[7,7],[4,3],[12,1],[2,2],[7,6],[4,6],[7,9],[7,2],[3,8],[1,6],[11,3],[11,4],[5,9],[13,8],[1,9],[10,1],[9,1],[6,1],[10,9],[12,9],[11,5],[8,1],[13,5],[9,6],[13,2],[6,8],[2,8],[5,3],[3,3],[13,1],[11,9],[9,3],[2,4],[5,2],[8,5],[13,7],[12,8],[5,5],[7,1],[7,4],[2,5],[6,9],[4,7],[5,8],[1,5],[10,8],[8,4],[1,1],[3,9],[1,2],[7,8],[1,7],[6,7],[11,6],[4,5],[5,7],[2,3],[10,4],[5,4],[12,3]])) # 35