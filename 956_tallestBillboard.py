"""
你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。
你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。
返回 广告牌的最大可能安装高度 。如果没法安装广告牌，请返回 0 。

自己写的超时了，跟Cursor学写动态规划。这题关键在于定义状态，利用高度差就可以减少一个维度。

动态规划思路：
- dp[diff] 表示当两个支架的高度差为 diff 时，较矮支架的最大高度
- 对于每根钢筋，有三种选择：
  1. 不使用这根钢筋
  2. 放在较矮的支架上（增加高度差）
  3. 放在较高的支架上（减少高度差，或使较矮的变成较高的）

========================================
动态规划状态定义的核心原则：
========================================

1. **识别问题的关键变量**
   - 找出影响最终答案的所有关键因素
   - 例如：位置、剩余资源、当前状态等

2. **选择合适的状态维度**
   - 一维：dp[i] - 通常表示位置、长度、容量等单一维度
   - 二维：dp[i][j] - 通常表示两个相关变量
   - 多维：dp[i][j][k] - 多个相关变量
   - 字典：dp[key] - 当状态空间稀疏或复杂时

3. **状态定义要满足的性质**
   - **无后效性**：当前状态只依赖于之前的状态，不影响之后的状态
   - **最优子结构**：问题的最优解包含子问题的最优解
   - **状态转移清晰**：能够明确地从已知状态推导出新状态

4. **常见状态定义模式**

   a) **线性DP**：dp[i] 表示前i个元素的最优值
      - 例：最长上升子序列 dp[i] = 以第i个元素结尾的最长上升子序列长度
   
   b) **背包DP**：dp[i][w] 表示前i个物品，容量为w时的最优值
      - 例：0-1背包 dp[i][w] = 前i个物品，容量w的最大价值
   
   c) **区间DP**：dp[i][j] 表示区间[i, j]的最优值
      - 例：矩阵链乘法 dp[i][j] = 矩阵i到j的最小乘法次数
   
   d) **状态压缩DP**：dp[mask] 表示某种状态组合
      - 例：旅行商问题 dp[mask][i] = 访问过mask中的城市，当前在i的最短路径
   
   e) **差值/差值DP**：dp[diff] 表示差值为diff时的最优值
      - 例：本题 dp[diff] = 高度差为diff时，较矮支架的最大高度
      - 例：494题 dp[sum] = 和为sum的表达式的数量

5. **状态定义的技巧**

   a) **从问题出发**：直接定义"要求什么，状态就表示什么"
      - 但有时需要间接定义（如本题用差值而非两个支架的具体高度）
   
   b) **降维优化**：如果状态转移只依赖前一层，可以压缩空间
      - 背包问题：dp[i][w] -> dp[w]（从后往前遍历）
   
   c) **状态合并**：将等价状态合并，减少状态空间
      - 本题：只记录高度差，不记录两个支架的具体高度
   
   d) **使用字典**：当状态空间稀疏时，用字典比数组更高效
      - 本题：高度差可能的值远小于所有可能的高度组合

6. **本题的状态定义分析**

   问题：需要两个高度相等的支架，求最大高度
    
   直接思路（不可行）：
   - dp[i][h1][h2] = 前i根钢筋，支架1高度h1，支架2高度h2是否可行
   - 状态空间太大：O(n * sum²)
   
   优化思路（可行）：
   - 注意到我们只关心两个支架的高度差，不关心具体高度
   - dp[diff] = 高度差为diff时，较矮支架的最大高度
   - 状态空间：O(sum)，大大减少
   
   为什么这样定义？
   - 两个支架的具体高度不重要，重要的是它们的差值和较矮的高度
   - 当diff=0时，两个支架高度相等，此时较矮支架的高度就是答案
   - 状态转移时，只需要考虑差值的变化，不需要记录两个具体高度
"""


def tallestBillboard(rods):
    """
    使用动态规划求解
    
    时间复杂度: O(n * sum(rods))
    空间复杂度: O(sum(rods))
    
    状态定义：dp[diff] = 高度差为diff时，较矮支架的最大高度
    
    状态转移：
    - 对于每根钢筋rod，有三种选择：
      1. 不使用：状态不变
      2. 放在较矮支架：diff -> diff + rod，较矮高度不变
      3. 放在较高支架：diff -> |diff - rod|，较矮高度增加 min(diff, rod)
    """
    # dp[diff] 表示高度差为 diff 时，较矮支架的最大高度
    dp = {0: 0}  # 初始状态：高度差为0，较矮支架高度为0
    
    for rod in rods:
        # 需要创建新的字典，因为我们在遍历过程中会修改 dp
        new_dp = dp.copy()
        
        for diff, short_height in dp.items():
            # 情况1: 不使用这根钢筋（已经在 new_dp 中通过 copy 保留了）
            
            # 情况2: 放在较矮的支架上
            # 新的高度差 = diff + rod
            # 较矮支架的高度不变（仍然是 short_height）
            new_diff1 = diff + rod
            new_dp[new_diff1] = max(new_dp.get(new_diff1, 0), short_height)
            
            # 情况3: 放在较高的支架上
            # 如果 rod <= diff: 新的高度差 = diff - rod，较矮支架高度 = short_height + rod
            # 如果 rod > diff: 新的高度差 = rod - diff，较矮支架高度 = short_height + diff
            if rod <= diff:
                new_diff2 = diff - rod
                new_short2 = short_height + rod
            else:
                new_diff2 = rod - diff
                new_short2 = short_height + diff
            
            new_dp[new_diff2] = max(new_dp.get(new_diff2, 0), new_short2)
        
        dp = new_dp
    
    # 返回高度差为0时，较矮支架的高度（即两个支架的高度）
    return dp.get(0, 0)


# 测试用例
if __name__ == "__main__":
    # 示例 1
    print(tallestBillboard([1, 2, 3, 6]))  # 输出: 6
    # 解释: {1,2,3} 和 {6} 两个子集，和都为6
    
    # 示例 2
    print(tallestBillboard([1, 2, 3, 4, 5, 6]))  # 输出: 10
    # 可能的组合: {1,2,3,4} 和 {5,5} 或 {1,4,5} 和 {2,3,5} 等
    
    # 示例 3
    print(tallestBillboard([1, 2]))  # 输出: 0
    # 无法找到两个和相等的子集
    
    # 示例 4
    print(tallestBillboard([1,2,4,8,16,32,64,128,256,512,50,50,50,150,150,150,100,100,100,123]))  # 1023
