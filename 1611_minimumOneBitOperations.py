###
# 给你一个整数 n，你需要重复执行多次下述操作将其转换为 0 ：
# 翻转 n 的二进制表示中最右侧位（第 0 位）。
# 如果第 (i-1) 位为 1 且从第 (i-2) 位到第 0 位都为 0，则翻转 n 的二进制表示中的第 i 位。
# 返回将 n 转换为 0 的最小操作次数。
#
# 100->101->111->110->010->011->001->000
# f[2^k] = f[2^(k-1)]*2 + 1 -> (f[2^k] + 1) = 2*(f[2^(k-1)] + 1) = 2^(k+1) (当k=1， f[1]=1)
# f[2^k] = 2^(k+1) - 1
# 对于不是2的k次方的数n，必然是2^(k-1)变为0的转换过程中的一个数（k是n的二进制表示的位数），所以可以用全链路
# 减去2^(k-1)变为n需要的次数。把2^(k-1)和n抹去最高位（就是0和n-2^(k-1)）再倒过来看，就变成了n-2^(k-1)
# 转换为0的过程了。用递归实现。
class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        if n <= 1:
            return n
        # highest bit is 2^(k-1)=1 << (k-1)
        k = n.bit_length()
        # print(f"n:{n}, k:{k}")
        # f[n] = 2^k-1-f[n-2^(k-1)]
        return (1 << k) - 1 - self.minimumOneBitOperations(n - (1 << (k - 1)))
